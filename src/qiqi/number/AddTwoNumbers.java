package qiqi.number;

/**
 *题目：
 * 写一个函数，求两个整数之和，要求在函数体内不得适用+，-，* ，./  四则运算符号。
 *
 * 解题思路
 * 首先我们分析人们是如何进行十进制的加法的，比如如何得出5+17=22这个结果的，实际上，我们可以分三步进行：第一步只做各位相加不进位，
 * 此时相加的结果是12，第二步做进位，5+7中有进位，进位的值为10；第三步，把前面的两个结果加起来12+10的结果是22，刚好5+17=22
 *
 * 我们一直在想，求两个数之和四则运算都不能用，还能用什么？对数字做运算，除了四则运算之外，也就只剩下位运算了。位运算是针对二进制的，
 * 我们就以二进制再来分析一下前面的三步走的策略对二进制是不是也适用。
 *
 * 5的二进制是101，17的二进制是10001，还是试着把计算分成三步：第一步各位相加但不计进位，得到的结果是10100；第二步记下进位。
 * 在这个例子中只在最后一位相加时产生进位，结果是二进制的10，第三步把前两步的结果相加，得到的结果是10110，转换成十进制刚好是22，
 * 由此可见三步走的策略对二进制也是适用的。
 *
 * 接下来我们试着把二进制的加法用位运算来替换。第一步不考虑进位对每一位相加。0+0，1+1的结果都是0，1+0的结果是1。0+1的结果是1，
 * 我们注意到这和异或的结果是一样的。对异或而言，0和0，1和1异或的结果是0，而0和1，1和0的异或结果是1，接着考虑第二步进位，对0+0，0+1，1+0而言，都不会产生进位，只有1+1时，会向前差生一个进位。此时我们可以想象成是两个数先做位与运算，然后再向前左移动一位。只有两个数都是1的时候，位与得到的结果是1，其余都是0。第三步相加的过程是重复前面的两步，直到不产生进位为止。
 * 例子：5+7
 * 相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111=010
 *
 * 计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101&111)<<1。
 *
 * 重复上述两步， 各位相加 010^1010=1000，进位值为100=(010&1010)<<1。
 *
 * 继续重复上述两步：1000^100 = 1100，进位值为0，跳出循环，1100为最终结果。
 */
public class AddTwoNumbers {

    public static int add(int num1, int num2){
        int sum, carry;
        do{
            sum = num1 ^ num2;    //异或
            carry = (num1&num2) <<1; //与操作 然后左移
            num1 = sum;
            num2 = carry;
        }while(num2 != 0);
        return num1;
    }

    public static void main(String[] args) {
        System.out.println(add(5, 7));
    }
}
